[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

특정 주식의 가격을 나타내는 prices 정수 배열을 전달받아 가장 큰 수익을 찾아 반환하는 문제이다.

<pre><strong>Input:</strong> prices = [7,1,5,3,6,4]
</pre>

위 배열처럼 각 인덱스는 날을 의미하며 인덱스 요소의 값은 가격을 의미한다. 예를들어 첫째날에는 주식의 값이 7이다. 만약 첫째날(0) 주식을 구매했다면 보다시피 다음날 부터는 마이너스 수익을 얻을 수 밖에 없다.

둘째날(1) 1이라는 가격에 주식을 구매했다면 다섯째날(4) 6이라는 가격에 팔아서 주어진 prices에서는 가장 큰 수익 5를 얻고 문제에서는 이 가장 큰 수익을 반환하면 된다. 만약 모든 경우의 수를 따져도 마이너스 수익이라면 0을 반환한다. 따라서 다음과 같이 코드 계획을 세웠다.

1. 구매할 수 있는 구간을 탐색 (0번 인덱스 ~ 마지막 인덱스 - 1)
2. 판매할 수 있는 구간을 탐색 (구매 날짜 + 1번 인덱스 ~ 마지막 인덱스)
3. 위의 구간을 탐색하며 얻는 수익을 `int max` 에 넣는다.
4. 1~3 과정을 반복하며 max에는 더 큰 수익을 넣고 모든 경우의 수를 확인 후 최종 max을 반환한다.

그리고 다음과 같이 코드를 작성하였다.

```java
// 풀이 실패: Time Limit Exceeded
public int maxProfit(int[] prices) {
    int max = 0;
    for (int i = 0; i < prices.length - 1; i++) { // 구매 구간
        for (int j = i + 1; j < prices.length; j++) { // 판매 구간
            max = max(max, prices[j] - prices[i]); // 판매가격 - 구매가격
        }
    }
    return max;
}
```

시간 제한으로 풀이는 실패하였다. 이유는 모든 경우의 수를 탐색하기 때문에 중복된 구매가격과 판매가격을 여러번 접한다.

<pre>prices = [7,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0]
</pre>

예를들어 0번째 인덱스와 5번 인덱스에 7이 있다. 0번째 인덱스에서 먼저 7이라는 가격에 주식을 구매하였고 그 다음 날부터 판매 가능한 모든 날짜를 탐색하면 5번 인덱스에 있는 7의 가격에 구매를 했을 경우엔 더는 탐색하지 않아도 된다. 이미 앞에 동일한 구매 가격에 모든 수익 결과를 찾았기 때문이다. 만약 위 prices 보다 훨씬 많은 중복 과정이 발생한다면 내가 풀이한 코드는 Runtime 시간이 굉장히 오래 걸릴 것이다.

이를 해결하기 위해 구매 구간의 중복 과정을 제외하기로 하고 Set을 사용했다.

```java
// 857 ms, 55.7 MB
public int maxProfit(int[] prices) {
    int max = 0;
    Set<Integer> set = new HashSet<>(); // 구매 가격을 기록해 중복된 가격은 재탐색을 하지 않기 위한 용도
    for (int i = 0; i < prices.length - 1; i++) {
        if (!set.contains(prices[i])) {
            for (int j = i + 1; j < prices.length; j++) {
                max = max(max, prices[j] - prices[i]);
            }
        }
        set.add(prices[i]);
    }
    return max;
}
```

구매 가능한 날짜를 탐색하는 바깥 for문을 시작할때 Set에 구매한 가격이 있는지 확인하는 과정으로 처음 구매한 가격에 대해서만 판매 가능한 날짜를 탐색하게 하여 불필요한 반복을 줄여 해결했다. 하지만 아직 개선할 수 있는 부분이 있어보인다.

다른 풀이들을 확인해보니 판매 구간을 탐색하는 부분 또한 중복된 부분을 제외할 수 있는 것 같은데 이 부분에 대해 추가적인 개선 작업을 할 수 있을 것 같다.
